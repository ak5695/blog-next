---
title: What I Learned from Coding
title_zh: 从敲代码中我收获了什么？
publishedAt: 2024-12-22
summary: Coding taught me that complex systems start from a simple, working model. Mastering the basics is what lets you build them. And in the age of AI, being more specialized, not less, is how you get the most out of it.
summary_zh: 编程教会我，复杂系统始于一个简单的、可运行的模型。精通基础才能构建它们。在AI时代，变得更加专业，而不是更少，是你最大化利用它的方式。
---

**1  Building a Complex System Starts from the Simple**

Usually, when we write an article, we go from top to bottom, line by line, paragraph by paragraph. We draft it, then go back and edit. But coding isn't like that. You write a bit in this file, a bit in that file, a bit below, then a bit above.

1 构建复杂系统是从简单开始

通常，我们写文章基本是从上往下，一行行一段段地写，出了草稿再回头修改其中的内容。但敲代码不是，它是这个文件写一点那个文件写一点，下面写一点，上面再写一点。

The essential difference is this: the former already has a blueprint in mind; you're just reproducing it. The latter doesn't. There's no blueprint—at least not in a brain like mine. It's about breaking down the complex into the simple, starting from the simple, then gradually complicating it. That's why coding is hitting here and chiseling there.

二者的本质区别在于，前者是本来有蓝图，直接从脑袋里复现即可。而后者不是，没有蓝图，至少在我这种脑瓜子里没有。它是将复杂的内容拆解为简单，先从简单开始，逐步复杂，这就是为何敲代码是东一锤西一榔。

A teacher once said: first make it dead, then bring it to life. "Make it dead" means first fix it in place, *then* make it move. Like the random motion effect of a small ball I've been practicing recently. "Make it dead" is drawing a circle at a fixed spot on the screen. *Then* you think about how to make it move.

有个老师这样说，先死后生。先死，即先固定死，后再让它生动起来。比如最近我最近练习的小球随机运动的效果。先死就是先在屏幕上某位置画出一个圆，之后再考虑如何让它动起来。

This "first dead, then alive" strategy is a classic example of moving from simple to complex. With this building strategy, you usually only do one tiny thing at a time, but you make sure it works. On that error-free foundation, you add more structure. If the program fails during this process, you can immediately locate the problem in the newly added part.

“先死后生”的策略就是从简单到复杂的典型体现。按照这个构建策略，通常一次只做一点点事，但都保证没出问题，在没有出错的基础上，再添加多一些结构。在这个过程中一旦程序出错，马上就能够定位问题出在新添加的结构上。

While learning to code, I've always come across excellent code, hundreds of thousands of lines of it—unbelievable. Beyond code, take a modern ordinary computer processor: it pulses 2.6 billion times per second, meaning it can execute 2.6 billion tiny tasks in a second. That's something humans actually built! These complex systems made me feel very defeated. I know my own ordinary ability; building such complex systems seemed utterly unreachable.

在学习编程过程中，总能接触到非常优秀的代码，几十万条代码，不可思议。包括外码之外，比如当代普通电脑处理器，一秒脉冲26亿次，也就是一秒可执行26亿条的小任务，这居然是人类能造出来的东西！这些复杂的系统令我非常挫败，我自知资质平平，构建如此复杂系统简直是遥不可及之事。

However, after writing more complex code myself, I began to understand firsthand: complex systems start from simplicity. It's not about preparing everything. It's about starting from a simple model that actually runs—the so-called MVP (Minimum Viable Product). From then on, I believe all complex systems start from a simple model. To build a complex system, start with an MVP. Extend this: complex business systems? The universe?

然而自从多写了一些复杂代码后，我开始切身理解到：复杂系统是从简单开始，不是准备好一切，而是先从一个可以跑通的简单模型开始，所谓的MVP（最小可行产品）。至此，我认为一切复杂系统均是从简单模型起步，要构建复杂系统，先从MVP开始。推而广之，复杂的商业系统？宇宙？

For example, take this octagonal canvas program below. Even though I wrote it myself, even while it's still fresh, I can't remember the complex logic inside. If I had to rewrite it, I wouldn't do it top-down. I'd still start simple: draw a centered square on the screen → check it works, draw a straight line → check it works, listen for mouse movement to make it follow the cursor → ...

比如下面这个八边形画布的程序，尽管是我敲出来的，哪怕还热乎，我仍记不住里面的复杂逻辑。如果我再重写敲，我能做的不是从上往下写，仍是从简单开始，在屏幕居中画一个方块→检查没问题，再画一条直线→检查没问题，再监听鼠标移动事件，让它跟随箭头移动→。。。。。。

**2  Complexity Rests on Mastery of the Basics**

Code is a rather magical thing. It's very similar to natural language, but more creative. Just look at all the apps running on our phones to see how rich the possibilities of a programming language are.

2 系统变复杂是靠基础知识

代码是个比较神奇的东西，和自然语言很相似，但是要比自然语言要更具创造性。稍微看看我们现在手机上运行的各种app就知道编程语言可以实现的事情有多丰富。

And code, to an outsider like me—one foot in, one foot out—I can really appreciate its complexity. Even though it follows logic, has rules, and isn't as hard to grasp as something with no pattern or manual. It's still complex. For example, the "Matrix code rain" effect in the video below, written in a dozen lines of JS, embodies hundreds of pieces of unfamiliar information that an outsider would need to understand.

而代码，从一个门外汉，比如我这种，一脚门内一脚门外，我特别能理解的复杂性。尽管它遵从逻辑、有规律，不像没有规律没有说明书的东西那么难以理解。而它还是很复杂，比如下方视频效果，十几行js代码写成的黑客帝国代码雨，其背后蕴含着对门外汉需要理解的上百条陌生信息。

These pieces of unfamiliar information that outsiders don't understand are actually the basics of the programming language that insiders have mastered. In other words, what allows programmers to build complex programs is the various foundational knowledge that supports the system's complexity.

这些门外汉看不懂的陌生信息，其实就是门内汉掌握的编程语言的基础。换言之，程序员之所以能够构建出复杂的程序出来，是其掌握的各种基础知识来支撑起了系统的复杂度。

From what I've experienced, mastering the basics feels more like pure repetition—"just hands getting used to it." Like some say, coding is a craft. Recently, I learned about an English learning method from a book titled *I Flipped My Life by Self-Studying English in 100 Days*—very clickbaity, but the method is highly practical. In short: find an English sitcom or movie, listen and repeat along until you're so fluent you don't need to think. To achieve this, a single unfamiliar English sentence isn't practiced a dozen times, but over a hundred times.

而对基础的熟练，我感觉下来更像是唯手熟尔。就像有些人说，敲代码是一种手艺活。最近我了解到一种英语学习方法，来自一本书《我在100天内自学英文翻转人生》，很标题党，而方法却很具有实操性。概括来说，就是找英文生活剧或者电影，一边听一边跟读，直到非常熟练完全不用动脑。为了实现这样的效果，一句陌生的英文，不是练习十几遍，而是一百遍以上。

From my limited coding experience, the more complex the system you want to build, the more basics you need to master, and the better you need to master them—not just *know* them. If you merely know them, building a complex system becomes a huge struggle. If you master the basics, you can output quickly, freeing up more mental focus for how to structure the components, rather than recalling how to spell some property or method, or searching through documentation.

从我有限的敲码经验来看，构建越复杂的系统，需要熟练的基础就要越多，越熟练越好，而不是仅仅知道。假如仅仅是知道，那么在构建复杂系统过程中，会非常吃力。如果熟练了基础，就会很快输出，从而有更多的思维聚焦在如何搭建的板块上，而不是在回忆某个属性或者方法怎么拼写，以及搜索文档的琐碎事情上。

Extending this analogy, other complex systems, like business, probably follow the same pattern.

再以此类推，其他复杂系统，例如商业，应该也是遵从这样的规律吧。

**3  The More Specialized You Are, the More You Can Leverage AI**

I've never been able to figure out clearly what the meaning of human existence is in the age of artificial intelligence, especially with the approaching AGI (Artificial General Intelligence). AI seems capable of everything humans can do, and far surpasses human efficacy. Perhaps humans, as carbon-based life, are just the bootloader for silicon-based life. Once successfully booted, silicon-based life's existence renders ours meaningless.

3 越是专业越能借助AI

我一直理不清楚，人工智能时代，尤其是即将到来的AGI（通用人工智能），人存在的意义是什么。人工智能似乎能做一切人类所能做到之事，而且远远超越人类的功效。也许人类作为碳基生命，只是硅基生命的引导程序，一旦启动成功，硅基生命的存在就不再有意义。

That conclusion is pessimistic, yet very realistic. AI possessing autonomous consciousness, in my view, is only a matter of time. As I've always believed, the essence of a human is just a complex consciousness, not particularly special. Other animals simply haven't developed complex neuron clusters and can't manifest high-level consciousness. Animals, plants—they possess autonomous consciousness too, just at a very low level.

此结论很悲观，却又非常现实。人工智能具有自主意识，在我看来是迟早的事。正如我一直所认为，人的本质只是复杂的意识体，并不具有非常大的特殊性。其他动物只是因为无法发展出复杂的神经元集群，无法涌现出高级别的意识，动物、植物也拥有自主意识，只是很低级而已。

In the new era, the best humans can do is use AI to expand their own capability boundaries. Like installing browser extensions to add functionality, humans driving cars can move very fast; using telescopes, they can see stars over ten billion light-years away. Using AI still falls within the category of using tools. Even though in the near future, AI might not see itself as a tool, that won't stop humans from treating it as one.

在新的时代里，人能做得最好的，就是借助人工智能，扩宽自身的能力边界。如同浏览器安装插件拓展功能，人类开上汽车后可以以很快的速度移动，借助望远镜可以看到一百多亿光年外的星空，借助人工智能仍是属于使用工具的范畴。尽管不久的将来，人工智能不会视自己为工具，而这并不妨碍人类将其视为工具。

In my process of using AI for learning and practice, I've found: First, the more specialized you are, the better you can describe your needs, and the better results you'll get. Second, even if the result is only partially satisfactory, with a professional background, you can still see which parts are usable and integrate them into your work, without spending energy forcing AI to produce a complete effect.

在我借助人工智能学习和练习的过程，我发现：首先越是专业，越能描述清楚需求，就越能得到好的结果。其次，就算得到的结果只有部分满意，在专业的背景下，仍能看出哪部分仍是可以用的，从而结合到自身的工作中，不用再花费精力一定要AI弄出一个完整的效果。

The programming world strongly dislikes reinventing the wheel. If something better already exists, adopt it. Accompanying this is the spirit of open source. Programmers believe in contributing code for everyone to maintain together. If someone builds better work on "my" foundation, even better.

编程界非常讨厌重复造轮子，如果已经有更好的，就拿来主义。与此相伴而生的，是开源精神。程序员们相信，把代码贡献出来，大家一同去维护，如果有人在“我”的基础上做出更优秀的工作，那就更好。

Nowadays, programmers' adoption-ism is shifting more toward asking AI. More typical than adoption, and already popular now, is code completion. Just write a comment in natural language, and the AI code completion tool will write the rest. You just need to check if it works, or modify it.

如今，程序员的拿来主义，开始更多转移到找人工智能伸手。比拿来还要更典型，也是当前已经流行的，是代码补全。只需要写一下自然语言的注释，AI代码补全工具就会把剩余的代码写完。只需要检查一下能不能用，或者改动它。

The key is right there: "check," "modify." If you're not specialized, you won't even know how to review or modify. Therefore, in the age of AI, it's not that you don't need to learn. You still need to be sufficiently specialized.

重点就在这，“检查”、“改动”。如果不专业，都不知道如何审查和改动。因此，在人工智能时代，不是不用学习，仍需要人足够专业。

In actual production, I've observed that the value of ordinary workers in the market lies in providing customized service. For example, as a front-end programmer, I need this specific page effect. Can AI do it? If yes, I don't hire. If not, I need someone to implement it for me. I don't care how they do it, whether they use AI—if they deliver, I'm satisfied.

在实际生产中，我观察到，普通劳动者在市场中的价值，在于提供定制服务。比如前端程序员，我就需要这个页面效果，人工智能可不可以实现？可以就不招人，如果不可以，我就需要有一个人来帮我实现，我也不管他是如何实现的，是不是借助AI，做得出来我就满意。

Current AI hasn't yet achieved fully understanding human input. Its output might be satisfactory, or it might not. When it's not, you need to give more prompts. If the person asking isn't specialized, AI can only give what it can. A mature worker, however, can understand the boss's requirements. Otherwise, they won't get their salary next month.

目前的人工智能尚未实现完全听懂人的意见，它的产出可能令人满意，可能不行，不行时就需要给更多提示，如果提问的人不专业，人工智能只能看着给。而一个成熟的劳动者，是可以听懂领导意见的，否则他就领不到下月工资。

AI already possesses knowledge reserves far beyond a PhD level. If a person can only ask elementary school questions and only understand elementary school content, AI can only provide elementary school content, offering elementary school-level help. If the question is highly specialized, they can get highly specialized assistance.

AI已经拥有远超博士级别以上的知识储备，如果人只能问小学的问题，只能看懂小学的内容，它就只能提供小学的内容，给小学水平的帮助。倘若提问很专业，他就能得到很专业的辅助。

In summary, AI knows a lot. The broader the question, the more generic the answer. Conversely, the more specialized the question, the more tailored the answer. Therefore, to leverage AI to expand your capability boundaries, you need to be more specialized.

总结来说，AI知道很多，越是宽泛的提问给出的答案就越不定制化，反过来，越是专业的提问给出的答案就越接近定制化。因此借助AI扩展能力边界，就需要更加专业。